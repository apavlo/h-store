<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_60) on Thu Jun 18 16:18:50 EDT 2015 -->
<title>Conversion (Oracle - Berkeley DB Java API)</title>
<meta name="date" content="2015-06-18">
<link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Conversion (Oracle - Berkeley DB Java API)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Conversion.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><em><b>Berkeley DB</b><br><font size="-1"> version 6.1.26</font></em></div>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev Class</li>
<li><a href="../../../../com/sleepycat/persist/evolve/Converter.html" title="class in com.sleepycat.persist.evolve"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/sleepycat/persist/evolve/Conversion.html" target="_top">Frames</a></li>
<li><a href="Conversion.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">com.sleepycat.persist.evolve</div>
<h2 title="Interface Conversion" class="title">Interface Conversion</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Superinterfaces:</dt>
<dd>java.io.Serializable</dd>
</dl>
<hr>
<br>
<pre>public interface <span class="strong">Conversion</span>
extends java.io.Serializable</pre>
<div class="block">Converts an old version of an object value to conform to the current class
 or field definition.

 <p>The <code>Conversion</code> interface is implemented by the user.  A
 <code>Conversion</code> instance is passed to the <a href="../../../../com/sleepycat/persist/evolve/Converter.html#Converter(java.lang.String,%20int,%20java.lang.String,%20com.sleepycat.persist.evolve.Conversion)"><code>Converter.Converter(java.lang.String, int, java.lang.String, com.sleepycat.persist.evolve.Conversion)</code></a>
 constructor.</p>

 <p>The <code>Conversion</code> interface extends <code>Serializable</code> and the
 <code>Conversion</code> instance is serialized for storage using standard Java
 serialization.  Normally, the <code>Conversion</code> class should only have
 transient fields that are initialized in the <a href="../../../../com/sleepycat/persist/evolve/Conversion.html#initialize(com.sleepycat.persist.model.EntityModel)"><code>initialize(com.sleepycat.persist.model.EntityModel)</code></a> method.
 While non-transient fields are allowed, care must be taken to only include
 fields that are serializable and will not pull in large amounts of data.</p>

 <p>When a class conversion is specified, two special considerations
 apply:</p>
 <ol>
 <li>A class conversion is only applied when to instances of that class.  The
 conversion will not be applied when the class when it appears as a
 superclass of the instance's class.  In this case, a conversion for the
 instance's class must also be specified.</li>
 <li>Although field renaming (as well as all other changes) is handled by the
 conversion method, a field Renamer is still needed when a secondary key
 field is renamed and field Deleter is still needed when a secondary key
 field is deleted.  This is necessary for evolution of the metadata;
 specifically, if the key name changes the database must be renamed and if
 the key field is deleted the secondary database must be deleted.</li>
 </ol>

 <p>The <code>Conversion</code> class must implement the standard equals method.
 See <a href="../../../../com/sleepycat/persist/evolve/Conversion.html#equals(java.lang.Object)"><code>equals(java.lang.Object)</code></a> for more information.</p>

 <p>Conversions of simple types are generally simple.  For example, a <code>String</code> field that contains only integer values can be easily converted to
 an <code>int</code> field:</p>
 <pre class="code">
  // The old class.  Version 0 is implied.
  //
  @Persistent
  class Address {
      String zipCode;
      ...
  }

  // The new class.  A new version number must be assigned.
  //
  @Persistent(version=1)
  class Address {
      int zipCode;
      ...
  }

  // The conversion class.
  //
  class MyConversion1 implements Conversion {

      public void initialize(EntityModel model) {
          // No initialization needed.
      }

      public Object convert(Object fromValue) {
          return Integer.valueOf((String) fromValue);
      }

      <code>@Override</code>
      public boolean equals(Object o) {
          return o instanceof MyConversion1;
      }
  }

  // Create a field converter mutation.
  //
  Converter converter = new Converter(Address.class.getName(), 0,
                                      "zipCode", new MyConversion1());

  // Configure the converter as described <a href="../../../../com/sleepycat/persist/evolve/Mutations.html" title="class in com.sleepycat.persist.evolve"><code>here</code></a>.</pre>

 <p>A conversion may perform arbitrary transformations on an object.  For
 example, a conversion may transform a single String address field into an
 Address object containing four fields for street, city, state and zip
 code.</p>
 <pre class="code">
  // The old class.  Version 0 is implied.
  //
  @Entity
  class Person {
      String address;
      ...
  }

  // The new class.  A new version number must be assigned.
  //
  @Entity(version=1)
  class Person {
      Address address;
      ...
  }

  // The new address class.
  //
  @Persistent
  class Address {
      String street;
      String city;
      String state;
      int zipCode;
      ...
  }

  class MyConversion2 implements Conversion {
      private transient RawType addressType;

      public void initialize(EntityModel model) {
          addressType = model.getRawType(Address.class.getName());
      }

      public Object convert(Object fromValue) {

          // Parse the old address and populate the new address fields
          //
          String oldAddress = (String) fromValue;
          Map&lt;String, Object&gt; addressValues = new HashMap&lt;String, Object&gt;();
          addressValues.put("street", parseStreet(oldAddress));
          addressValues.put("city", parseCity(oldAddress));
          addressValues.put("state", parseState(oldAddress));
          addressValues.put("zipCode", parseZipCode(oldAddress));

          // Return new raw Address object
          //
          return new RawObject(addressType, addressValues, null);
      }

      <code>@Override</code>
      public boolean equals(Object o) {
          return o instanceof MyConversion2;
      }

      private String parseStreet(String oldAddress) { ... }
      private String parseCity(String oldAddress) { ... }
      private String parseState(String oldAddress) { ... }
      private Integer parseZipCode(String oldAddress) { ... }
  }

  // Create a field converter mutation.
  //
  Converter converter = new Converter(Person.class.getName(), 0,
                                      "address", new MyConversion2());

  // Configure the converter as described <a href="../../../../com/sleepycat/persist/evolve/Mutations.html" title="class in com.sleepycat.persist.evolve"><code>here</code></a>.</pre>

 <p>Note that when a conversion returns a <a href="../../../../com/sleepycat/persist/raw/RawObject.html" title="class in com.sleepycat.persist.raw"><code>RawObject</code></a>, it must return
 it with a <a href="../../../../com/sleepycat/persist/raw/RawType.html" title="interface in com.sleepycat.persist.raw"><code>RawType</code></a> that is current as defined by the current class
 definitions.  The proper types can be obtained from the <a href="../../../../com/sleepycat/persist/model/EntityModel.html" title="class in com.sleepycat.persist.model"><code>EntityModel</code></a>
 in the conversion's <a href="../../../../com/sleepycat/persist/evolve/Conversion.html#initialize(com.sleepycat.persist.model.EntityModel)"><code>initialize</code></a> method.</p>

 <p>A variation on the example above is where several fields in a class
 (street, city, state and zipCode) are converted to a single field (address).
 In this case a class converter rather than a field converter is used.</p>

 <pre class="code">
  // The old class.  Version 0 is implied.
  //
  @Entity
  class Person {
      String street;
      String city;
      String state;
      int zipCode;
      ...
  }

  // The new class.  A new version number must be assigned.
  //
  @Entity(version=1)
  class Person {
      Address address;
      ...
  }

  // The new address class.
  //
  @Persistent
  class Address {
      String street;
      String city;
      String state;
      int zipCode;
      ...
  }

  class MyConversion3 implements Conversion {
      private transient RawType newPersonType;
      private transient RawType addressType;

      public void initialize(EntityModel model) {
          newPersonType = model.getRawType(Person.class.getName());
          addressType = model.getRawType(Address.class.getName());
      }

      public Object convert(Object fromValue) {

          // Get field value maps for old and new objects.
          //
          RawObject person = (RawObject) fromValue;
          Map&lt;String, Object&gt; personValues = person.getValues();
          Map&lt;String, Object&gt; addressValues = new HashMap&lt;String, Object&gt;();
          RawObject address = new RawObject(addressType, addressValues, null);

          // Remove the old address fields and insert the new one.
          //
          addressValues.put("street", personValues.remove("street"));
          addressValues.put("city", personValues.remove("city"));
          addressValues.put("state", personValues.remove("state"));
          addressValues.put("zipCode", personValues.remove("zipCode"));
          personValues.put("address", address);

          return new RawObject(newPersonType, personValues, person.getSuper());
      }

      <code>@Override</code>
      public boolean equals(Object o) {
          return o instanceof MyConversion3;
      }
  }

  // Create a class converter mutation.
  //
  Converter converter = new Converter(Person.class.getName(), 0,
                                      new MyConversion3());

  // Configure the converter as described <a href="../../../../com/sleepycat/persist/evolve/Mutations.html" title="class in com.sleepycat.persist.evolve"><code>here</code></a>.</pre>


 <p>A conversion can also handle changes to class hierarchies.  For example,
 if a "name" field originally declared in class A is moved to its superclass
 B, a conversion can move the field value accordingly:</p>

 <pre class="code">
  // The old classes.  Version 0 is implied.
  //
  @Persistent
  class A extends B {
      String name;
      ...
  }
  @Persistent
  abstract class B {
      ...
  }

  // The new classes.  A new version number must be assigned.
  //
  @Persistent(version=1)
  class A extends B {
      ...
  }
  @Persistent(version=1)
  abstract class B {
      String name;
      ...
  }

  class MyConversion4 implements Conversion {
      private transient RawType newAType;
      private transient RawType newBType;

      public void initialize(EntityModel model) {
          newAType = model.getRawType(A.class.getName());
          newBType = model.getRawType(B.class.getName());
      }

      public Object convert(Object fromValue) {
          RawObject oldA = (RawObject) fromValue;
          RawObject oldB = oldA.getSuper();
          Map&lt;String, Object&gt; aValues = oldA.getValues();
          Map&lt;String, Object&gt; bValues = oldB.getValues();
          bValues.put("name", aValues.remove("name"));
          RawObject newB = new RawObject(newBType, bValues, oldB.getSuper());
          RawObject newA = new RawObject(newAType, aValues, newB);
          return newA;
      }

      <code>@Override</code>
      public boolean equals(Object o) {
          return o instanceof MyConversion4;
      }
  }

  // Create a class converter mutation.
  //
  Converter converter = new Converter(A.class.getName(), 0,
                                      new MyConversion4());

  // Configure the converter as described <a href="../../../../com/sleepycat/persist/evolve/Mutations.html" title="class in com.sleepycat.persist.evolve"><code>here</code></a>.</pre>

 <p>A conversion may return an instance of a different class entirely, as
 long as it conforms to current class definitions and is the type expected
 in the given context (a subtype of the old type, or a type compatible with
 the new field type).  For example, a field that is used to discriminate
 between two types of objects could be removed and replaced by two new
 subclasses:</p> <pre class="code">
  // The old class.  Version 0 is implied.
  //
  @Persistent
  class Pet {
      boolean isCatNotDog;
      ...
  }

  // The new classes.  A new version number must be assigned to the Pet class.
  //
  @Persistent(version=1)
  class Pet {
      ...
  }
  @Persistent
  class Cat extends Pet {
      ...
  }
  @Persistent
  class Dog extends Pet {
      ...
  }

  class MyConversion5 implements Conversion {
      private transient RawType newPetType;
      private transient RawType dogType;
      private transient RawType catType;

      public void initialize(EntityModel model) {
          newPetType = model.getRawType(Pet.class.getName());
          dogType = model.getRawType(Dog.class.getName());
          catType = model.getRawType(Cat.class.getName());
      }

      public Object convert(Object fromValue) {
          RawObject pet = (RawObject) fromValue;
          Map&lt;String, Object&gt; petValues = pet.getValues();
          Boolean isCat = (Boolean) petValues.remove("isCatNotDog");
          RawObject newPet = new RawObject(newPetType, petValues,
                                           pet.getSuper());
          RawType newSubType = isCat ? catType : dogType;
          return new RawObject(newSubType, Collections.emptyMap(), newPet);
      }

      <code>@Override</code>
      public boolean equals(Object o) {
          return o instanceof MyConversion5;
      }
  }

  // Create a class converter mutation.
  //
  Converter converter = new Converter(Pet.class.getName(), 0,
                                      new MyConversion5());

  // Configure the converter as described <a href="../../../../com/sleepycat/persist/evolve/Mutations.html" title="class in com.sleepycat.persist.evolve"><code>here</code></a>.</pre>

 <p>The primary limitation of a conversion is that it may access at most a
 single entity instance at one time.  Conversions involving multiple entities
 at once may be made by performing a <a
 href="package-summary.html#storeConversion">store conversion</a>.</p></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../com/sleepycat/persist/evolve/package-summary.html"><code>Class Evolution</code></a></dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../../../com/sleepycat/persist/evolve/Conversion.html#convert(java.lang.Object)">convert</a></strong>(java.lang.Object&nbsp;fromValue)</code>
<div class="block">Converts an old version of an object value to conform to the current
 class or field definition.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../com/sleepycat/persist/evolve/Conversion.html#equals(java.lang.Object)">equals</a></strong>(java.lang.Object&nbsp;other)</code>
<div class="block">The standard <code>equals</code> method that must be implemented by
 conversion class.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../com/sleepycat/persist/evolve/Conversion.html#initialize(com.sleepycat.persist.model.EntityModel)">initialize</a></strong>(<a href="../../../../com/sleepycat/persist/model/EntityModel.html" title="class in com.sleepycat.persist.model">EntityModel</a>&nbsp;model)</code>
<div class="block">Initializes the conversion, allowing it to obtain raw type information
 from the entity model.</div>
</td>
</tr>
</table>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="initialize(com.sleepycat.persist.model.EntityModel)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initialize</h4>
<pre>void&nbsp;initialize(<a href="../../../../com/sleepycat/persist/model/EntityModel.html" title="class in com.sleepycat.persist.model">EntityModel</a>&nbsp;model)</pre>
<div class="block">Initializes the conversion, allowing it to obtain raw type information
 from the entity model.</div>
</li>
</ul>
<a name="convert(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convert</h4>
<pre>java.lang.Object&nbsp;convert(java.lang.Object&nbsp;fromValue)</pre>
<div class="block">Converts an old version of an object value to conform to the current
 class or field definition.

 <p>If a <code>RuntimeException</code> is thrown by this method, it will be
 thrown to the original caller.  Similarly, a <code>IllegalArgumentException</code> will be thrown to the original caller if the
 object returned by this method does not conform to current class
 definitions.</p>

 <p>The class of the input and output object may be one of the simple
 types or <a href="../../../../com/sleepycat/persist/raw/RawObject.html" title="class in com.sleepycat.persist.raw"><code>RawObject</code></a>.  For primitive types, the primitive wrapper
 class is used.</p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>fromValue</code> - the object value being converted.  The type of this
 value is defined by the old class version that is being converted.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the converted object.  The type of this value must conform to
 a current class definition.  If this is a class conversion, it must
 be the current version of the class.  If this is a field conversion, it
 must be of a type compatible with the current declared type of the
 field.</dd></dl>
</li>
</ul>
<a name="equals(java.lang.Object)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>equals</h4>
<pre>boolean&nbsp;equals(java.lang.Object&nbsp;other)</pre>
<div class="block">The standard <code>equals</code> method that must be implemented by
 conversion class.

 <p>When mutations are specified when opening a store, the specified and
 previously stored mutations are compared for equality.  If they are
 equal, there is no need to replace the existing mutations in the stored
 catalog.  To accurately determine equality, the conversion class must
 implement the <code>equals</code> method.</p>

 <p>If the <code>equals</code> method is not explicitly implemented by the
 conversion class or a superclass other than <code>Object</code>, <code>IllegalArgumentException</code> will be thrown when the store is opened.</p>

 <p>Normally whenever <code>equals</code> is implemented the <code>hashCode</code>
 method should also be implemented to support hash sets and maps.
 However, hash sets and maps containing <code>Conversion</code> objects
 are not used by the DPL and therefore the DPL does not require
 <code>hashCode</code> to be implemented.</p></div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code>equals</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Conversion.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><em><b>Berkeley DB</b><br><font size="-1"> version 6.1.26</font></em></div>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev Class</li>
<li><a href="../../../../com/sleepycat/persist/evolve/Converter.html" title="class in com.sleepycat.persist.evolve"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/sleepycat/persist/evolve/Conversion.html" target="_top">Frames</a></li>
<li><a href="Conversion.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small><font size=1>Copyright (c) 1996, 2015 Oracle and/or its affiliates.  All rights reserved.</font></small></p>
</body>
</html>
